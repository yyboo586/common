# 惊群问题的本质（用实际例子说明）

## 您的理解 vs 实际问题

### 您的理解（部分正确）

✅ **正确的部分**：
1. Worker 是按 TaskType 区分的（每个 TaskType 一个 Worker）
2. AddTask 时 next_retry_time = Now()，应该立即处理
3. 添加任务后调用 WakeUp，Worker 会立即处理

❌ **误解的部分**：
1. "添加几个任务，就应该唤醒几个 Worker" ← **不是每个任务一个 Worker！**
2. 多次调用 WakeUp 没问题 ← **信号会堆积！**

## 问题复现（用您的业务代码）

### 场景：handleExhibitionApprove

```go
func (e *exhibition) handleExhibitionApprove(...) {
    // 在事务中添加 1 个定时任务
    e.asyncTask.AddScheduledTask(ctx, tx, 
        model.TaskTypeExhibitionAutoStartEnrolling,  // TaskType = 6
        exhibition.ID, 
        taskContentBytes, 
        exhibition.RegistrationStart)  // 未来时间，例如 1小时后
    
    // 事务提交成功
    
    // 立即唤醒 Worker
    e.asyncTask.WakeUp(model.TaskTypeExhibitionAutoStartEnrolling)
}
```

**问题**：如果短时间内审批了 20 个展会，会发生什么？

## 时序分析

### 假设：连续审批 20 个展会

```
时刻 T0: 审批展会1
         AddScheduledTask(type=6, time=1小时后)
         WakeUp(type=6)  → channel: [信号1]

时刻 T1: 审批展会2
         AddScheduledTask(type=6, time=1小时后)
         WakeUp(type=6)  → channel: [信号1, 信号2]

时刻 T2: 审批展会3
         WakeUp(type=6)  → channel: [信号1, 信号2, 信号3]

...

时刻 T19: 审批展会20
          WakeUp(type=6)  → channel: [信号1...信号20]
```

**此时 channel 中有 20 个信号！**

### Worker 的执行流程

```
时刻 T20: Worker 被唤醒（消费信号1）
          
          FetchPendingTask(type=6)
          → SELECT ... WHERE task_type=6 AND next_retry_time < Now()
          → [rows:0] 因为所有任务都是 1 小时后执行
          
          GetMinNextRetryTime(type=6)
          → SELECT ... WHERE task_type=6 ORDER BY next_retry_time
          → [rows:1] 查到最早的任务（1小时后）
          
          nextFetchTime = 1小时后
          continue

时刻 T21: 回到 select
          ⚠️ channel 中还有信号2！
          立即被唤醒（不等待 1 小时）
          
          FetchPendingTask(type=6)
          → [rows:0] 还是 1 小时后才能执行
          
          GetMinNextRetryTime(type=6)
          → [rows:1] 还是那些任务
          
          continue

时刻 T22-T39: 重复上述过程（消费信号3...信号20）

总共执行：
  20 次 FetchPendingTask [rows:0]
  20 次 GetMinNextRetryTime [rows:1]
  = 40 次数据库查询！
```

**这就是您日志中看到的现象！**

## 关键问题

### 问题1：为什么不是每次添加任务就查询一次？

**回答**：因为这些是**定时任务**（未来时间），不是立即执行的任务！

```go
// 审批展会时，添加的是定时任务
AddScheduledTask(..., scheduledTime: exhibition.RegistrationStart)
// ↑ 这是未来时间（例如明天9点开始报名）

// dao.go
func (d *DAO) AddScheduledTask(..., scheduledTime time.Time) {
    data := g.Map{
        "next_retry_time": scheduledTime.Unix(),  // ← 未来时间！
    }
}
```

**对比**：立即执行的任务

```go
// handleExhibitionStartRunning 中添加立即执行的任务
AddTask(ctx, tx, model.TaskTypeExStartAndNotifyReservationUsers, ...)

// dao.go
func (d *DAO) AddTask(...) {
    data := g.Map{
        "next_retry_time": gtime.Now().Unix(),  // ← 当前时间，立即执行
    }
}
```

### 问题2：为什么会重复查询？

**回答**：因为 channel 中堆积了多个信号！

```go
// Worker 的 select
select {
case <-sigChan:  // 如果 channel 中有信号，立即返回（不等待定时器）
    // 查询任务...
    // continue 回到 select
    
case <-time.After(time.Until(nextFetchTime)):  // 这个分支不会执行
}
```

只要 channel 中还有信号，`case <-sigChan` 就会立即触发，导致重复查询。

## 正确的流程应该是什么？

### 理想情况（修复后）

```
时刻 T0: 审批 20 个展会
         添加 20 个定时任务（1小时后执行）
         调用 20 次 WakeUp(type=6)
         
         ⚠️ 但 channel 容量为 1，只保留 1 个信号

时刻 T1: Worker 被唤醒（消费 1 个信号）
         
         // 清空剩余信号（此时已经没有了）
         for len(sigChan) > 0 { <-sigChan }
         
         FetchPendingTask(type=6)
         → [rows:0] 都是未来任务
         
         GetMinNextRetryTime(type=6)
         → [rows:1] 查到最早的任务（1小时后）
         
         nextFetchTime = 1小时后
         continue

时刻 T2: 回到 select
         channel 中没有信号了
         等待定时器（1小时）
         
时刻 T3: 1小时后，定时器触发
         FetchPendingTask(type=6)
         → [rows:20] 查到 20 个任务
         
         依次处理这 20 个任务...

总共执行：
  1 次 FetchPendingTask [rows:0]（初次查询）
  1 次 GetMinNextRetryTime [rows:1]
  1 次 FetchPendingTask [rows:20]（1小时后）
  20 次 FetchPendingTask（处理每个任务）
  1 次 FetchPendingTask [rows:0]（队列空了）
  1 次 GetMinNextRetryTime
  = 24 次查询
  
而不是修复前的 40+ 次无效查询！
```

## 回答您的两个问题

### Q1: "添加几个任务，就应该唤醒几个对应的 Worker"

**A1**：理解有偏差

- ❌ 不是每个任务一个 Worker
- ✅ 每个 **TaskType** 一个 Worker
- ✅ 添加 N 个相同 TaskType 的任务，只需要唤醒 **1 次**
- ✅ Worker 会**串行**处理这 N 个任务

**示例**：
```go
// 添加 5 个任务
AddTask(type=6, ...)  // 任务1
AddTask(type=6, ...)  // 任务2
AddTask(type=6, ...)  // 任务3
AddTask(type=6, ...)  // 任务4
AddTask(type=6, ...)  // 任务5

WakeUp(type=6)  // 只调用 1 次即可！

// TaskType=6 的 Worker 会：
// 1. 处理任务1
// 2. 立即查询任务2（不需要再次 WakeUp）
// 3. 处理任务2
// 4. ...
// 5. 处理完全部 5 个任务
```

### Q2: "AddTask 时 NextRetryTime = Now()，应该立即处理"

**A2**：完全正确！

但您的业务代码中用的是 `AddScheduledTask`（定时任务）：

```go
// handleExhibitionApprove 中
AddScheduledTask(..., scheduledTime: exhibition.RegistrationStart)
//                                    ↑ 这是未来时间！
```

**区别**：
- `AddTask` → next_retry_time = **Now()**（立即执行）
- `AddScheduledTask` → next_retry_time = **scheduledTime**（未来时间）

惊群问题主要发生在**定时任务**场景：
1. 添加定时任务（未来时间）
2. 调用 WakeUp
3. Worker 被唤醒，但发现任务时间未到，查询返回空
4. 如果 channel 中还有信号，再次被唤醒，重复步骤3

## 修复的安全性证明

### 担心：信号被丢弃，任务会不会丢失？

**回答**：不会！有三重保障：

#### 保障1：Worker 会持续处理

```go
// 处理完任务1
handleTask(task1)
nextFetchTime = time.Now()  // ← 立即查询下一个

// 回到 select，立即触发
// 处理任务2，任务3...直到队列空
```

#### 保障2：定时器兜底

```go
select {
case <-sigChan:          // 信号（可能被合并）
case <-time.After(...):  // 定时器（一定会触发）
}
```

即使所有 WakeUp 信号都丢失，定时器也会在 `nextFetchTime` 触发。

#### 保障3：只有"多余"的信号被丢弃

- 第 1 个 WakeUp → 保留（channel 空的）
- 第 2-20 个 WakeUp → 丢弃（channel 满了）

但 Worker 只需要 1 个信号就能处理所有任务！

## 总结

| 项目 | 修复前 | 修复后 |
|------|--------|--------|
| 添加 20 个定时任务 | ✓ | ✓ |
| 调用 20 次 WakeUp | channel 堆积 20 个信号 | channel 只保留 1 个 |
| Worker 被唤醒次数 | 20 次 | 1 次 |
| 无效查询次数 | 40 次 | 2 次 |
| 任务是否正常处理 | ✓ | ✓ |
| 性能 | 差 | **好** |

**修复不会影响功能，只会提升性能！**
